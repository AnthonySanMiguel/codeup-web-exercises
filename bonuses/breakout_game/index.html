<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>

    // Creates JS variable for "canvas" as selected by HTML id
    var canvas = document.getElementById("myCanvas");

    // Creates variable to store 2D rendering context (tool to "paint" on our canvas)
    var ctx = canvas.getContext("2d");

    // Establish starting position (coordinates) of object created by "draw()" function
    var x = canvas.width/2;
    var y = canvas.height-30;

    // Will add incremental changes to x and y coordinates after every frame change
    var dx = 2;
    var dy = -2;

    // Sets ball radius for collision detection
    var ballRadius = 10;

    // Paddle Size
    var paddleHeight = 10;
    var paddleWidth = 75;

    // Paddle starting point on horizontal "x" axis
    var paddleX = (canvas.width - paddleWidth) / 2;

    // Values for key presses (left and right); default value is keys NOT pressed ("false")
    var leftPressed = false;
    var rightPressed = false;

    // ------ TEST SHAPES ------
    //
    //     // All 2D "context (ctx)" commands go between a ".beginPath()" and ".closePath()"
    //     ctx.beginPath();
    //         // "rect" specifies a rectangle shape...
    //             // 20px from left side of screen,
    //             // 40px from top of screen,
    //             // 50px wide,
    //             // 50px high
    //         ctx.rect(20, 40, 50, 50);
    //         // Filled with specified color...
    //         ctx.fillStyle = "#FF0000";
    //         ctx.fill();
    //     ctx.closePath();
    //
    //     ctx.beginPath();
    //         // "arc" allows for circular shapes, but needs 6 parameters...
    //             // x coordinates (240)
    //             // y coordinates (160)
    //             // arc radius (20)
    //             // starting angle (in radians; 0)
    //             // ending angle (in radians; Math.PI*2)
    //             // direction ("false" for clockwise, "true" for anti-clockwise)
    //         ctx.arc(240, 160, 20, 0, Math.PI*2, false);
    //         // Filled with specified color...
    //         ctx.fillStyle = "green";
    //         ctx.fill();
    //     ctx.closePath();
    //
    //     ctx.beginPath();
    //         // "rect" specifies a rectangle shape...
    //             // 20px from left side of screen,
    //             // 40px from top of screen,
    //             // 50px wide,
    //             // 50px high
    //         ctx.rect(160, 10, 100, 40);
    //         // Rather than "fill" command, "strokeStyle" only colors outside border (e.g. first stroke)
    //         ctx.strokeStyle = "rgba(0, 0, 255, 0.5)";
    //         ctx.stroke();
    //     ctx.closePath();
    //
    // ------ ------ ------

    function drawBall() {
        ctx.beginPath();
            // Use "x" and "y" coordinates as defined above
            ctx.arc(x, y, ballRadius, 0, Math.PI*2);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
        ctx.closePath();
    }

    function draw() {
        // Clears canvas (e.g. "Rectangle" shape) and takes 4 parameters...
        // x coordinate for top left corner of rectangle
        // y coordinate for top left corner of rectangle
        // x coordinate for bottom right corner of rectangle
        // y coordinate for bottom right corner of rectangle
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calls drawBall function above, which includes starting x and y position on canvas
        drawBall()

        // Calls drawPaddle function above, which includes starting x position on canvas
        drawPaddle()

        // After object is drawn by function, x and y values will change per specified incrememnts
        x = x + dx;
        y = y + dy;

        // COLLISION DETECTION:

        // KEEP BALL WITHIN CANVAS BOUNDARIES:
            // If the "x" coordinate of the ball RADIUS (circumference; not center) on the [horizontal axis] exceeds the canvas WIDTH -- OR -- is less than 0...REVERSE the movement (e.g. increment [2] or decrement [-2] "dx" variable as needed)
        // KEEP BALL FROM "BLENDING" INTO WALLS ON COLLISION:
            // When the distance between the center of the ball and the edge of the wall is exactly the same as the radius of the ball, reverse movement direction as above. Subtracting the radius from one edge's width and adding it onto the other gives us the impression of the proper collision detection.
        if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
        }

        // KEEP BALL WITHIN CANVAS BOUNDARIES:
            // If the "y" coordinate of the ball RADIUS (circumference; not center) on the [vertical axis] exceeds the canvas HEIGHT -- OR -- is less than 0...REVERSE the movement (e.g. increment or decrement [-2] "dy" variable as needed)
        // KEEP BALL FROM "BLENDING" INTO WALLS ON COLLISION:
            // When the distance between the center of the ball and the edge of the wall is exactly the same as the radius of the ball, reverse movement direction as above. Subtracting the radius from one edge's width and adding it onto the other gives us the impression of the proper collision detection.
        if(y + dy > canvas.height - ballRadius || y + dy < ballRadius) {
            dy = -dy;
        }

        // If right arrow is pressed, move paddle on the "x" axis to the right by 7px (+7)
        if(rightPressed) {
            paddleX = paddleX + 7;
            // If paddle position on "x" value exceeds canvas width (too much positive moving right), stop paddle by making its position the value of the canvas - paddle width
            if (paddleX + paddleWidth > canvas.width){
                paddleX = canvas.width - paddleWidth;
            }
        }
        // If left arrow is pressed, move paddle on the "x" axis to the left by 7px (-7)
        else if(leftPressed) {
            paddleX = paddleX - 7;
            // If paddle position on "x" value is LESS THAN 0 (too much negative moving left), stop paddle by making its position the value of 0 ("start" of canvas)
            if (paddleX < 0){
                paddleX = 0;
            }
        }
    }

    // Event listeners ("keydown" & "keyup" are standard)...on these actions, the respective functions (keyDownHandler or keyUpHandler) will run
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    // When we press a key down, this information is stored in the variable "key".
        // The relevant variable in each case is set to true...
        // Most browsers use ArrowRight and ArrowLeft for the left/right cursor keys, but we need to also include Right and Left checks to support IE/Edge browsers.
        function keyDownHandler(e) { // "e" equals "event" to LISTEN for
        if(e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = true;
        }
        else if(e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = true;
        }
    }

        // When the key is released, the variable is set back to false.
        // Most browsers use ArrowRight and ArrowLeft for the left/right cursor keys, but we need to also include Right and Left checks to support IE/Edge browsers.
    function keyUpHandler(e) {
        if(e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = false;
        }
        else if(e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = false;
        }
    }

    // "setInterval" is an infinite command which will call our "draw()" function every 10 milliseconds...or until we stop it
    setInterval(draw, 10);

</script>
</body>
</html>
