<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>

    // Creates JS variable for "canvas" as selected by HTML id
    var canvas = document.getElementById("myCanvas");

    // Creates variable to store 2D rendering context (tool to "paint" on our canvas)
    var ctx = canvas.getContext("2d");

    // Establish starting position (coordinates) of object created by "draw()" function
    var x = canvas.width/2;
    var y = canvas.height-30;

    // Will add incremental changes to x and y coordinates after every frame change
    var dx = 2;
    var dy = -2;

    // Sets ball radius for collision detection
    var ballRadius = 10;

    // ------ TEST SHAPES ------
    //
    //     // All 2D "context (ctx)" commands go between a ".beginPath()" and ".closePath()"
    //     ctx.beginPath();
    //         // "rect" specifies a rectangle shape...
    //             // 20px from left side of screen,
    //             // 40px from top of screen,
    //             // 50px wide,
    //             // 50px high
    //         ctx.rect(20, 40, 50, 50);
    //         // Filled with specified color...
    //         ctx.fillStyle = "#FF0000";
    //         ctx.fill();
    //     ctx.closePath();
    //
    //     ctx.beginPath();
    //         // "arc" allows for circular shapes, but needs 6 parameters...
    //             // x coordinates (240)
    //             // y coordinates (160)
    //             // arc radius (20)
    //             // starting angle (in radians; 0)
    //             // ending angle (in radians; Math.PI*2)
    //             // direction ("false" for clockwise, "true" for anti-clockwise)
    //         ctx.arc(240, 160, 20, 0, Math.PI*2, false);
    //         // Filled with specified color...
    //         ctx.fillStyle = "green";
    //         ctx.fill();
    //     ctx.closePath();
    //
    //     ctx.beginPath();
    //         // "rect" specifies a rectangle shape...
    //             // 20px from left side of screen,
    //             // 40px from top of screen,
    //             // 50px wide,
    //             // 50px high
    //         ctx.rect(160, 10, 100, 40);
    //         // Rather than "fill" command, "strokeStyle" only colors outside border (e.g. first stroke)
    //         ctx.strokeStyle = "rgba(0, 0, 255, 0.5)";
    //         ctx.stroke();
    //     ctx.closePath();
    //
    // ------ ------ ------

    function drawBall() {
        ctx.beginPath();
            // Use "x" and "y" coordinates as defined above
            ctx.arc(x, y, ballRadius, 0, Math.PI*2);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
        ctx.closePath();
    }

    function draw() {
        // Clears canvas (e.g. "Rectangle" shape) and takes 4 parameters...
        // x coordinate for top left corner of rectangle
        // y coordinate for top left corner of rectangle
        // x coordinate for bottom right corner of rectangle
        // y coordinate for bottom right corner of rectangle
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calls drawBall function above, which includes starting x and y position on canvas
        drawBall()

        // After object is drawn by function, x and y values will change per specified incrememnts
        x = x + dx;
        y = y + dy;

        // COLLISION DETECTION:

        // KEEP BALL WITHIN CANVAS BOUNDARIES:
            // If the "x" coordinate of the ball RADIUS (circumference; not center) on the [horizontal axis] exceeds the canvas WIDTH -- OR -- is less than 0...REVERSE the movement (e.g. increment [2] or decrement [-2] "dx" variable as needed)
        // KEEP BALL FROM "BLENDING" INTO WALLS ON COLLISION:
            // When the distance between the center of the ball and the edge of the wall is exactly the same as the radius of the ball, reverse movement direction as above. Subtracting the radius from one edge's width and adding it onto the other gives us the impression of the proper collision detection.
        if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
        }

        // KEEP BALL WITHIN CANVAS BOUNDARIES:
            // If the "y" coordinate of the ball RADIUS (circumference; not center) on the [vertical axis] exceeds the canvas HEIGHT -- OR -- is less than 0...REVERSE the movement (e.g. increment or decrement [-2] "dy" variable as needed)
        // KEEP BALL FROM "BLENDING" INTO WALLS ON COLLISION:
            // When the distance between the center of the ball and the edge of the wall is exactly the same as the radius of the ball, reverse movement direction as above. Subtracting the radius from one edge's width and adding it onto the other gives us the impression of the proper collision detection.
        if(y + dy > canvas.height - ballRadius || y + dy < ballRadius) {
            dy = -dy;
        }
    }

    // "setInterval" is an infinite command which will call our "draw()" function every 10 milliseconds...or until we stop it
    setInterval(draw, 10);

</script>
</body>
</html>
